package codegen

// WrapperTemplate is the template for generated wrapper functions
const WrapperTemplate = `// Code generated by lcc-codegen. DO NOT EDIT.

package {{.Package}}

import (
	"fmt"
	"log"
	
	"github.com/yourorg/lcc-sdk/pkg/client"
)

var (
	_lccClient *client.Client
	_lccInitialized bool
)

// _lccInit initializes the LCC client (called automatically)
func _lccInit() error {
	if _lccInitialized {
		return nil
	}
	
	// TODO: Load from config file
	// For now, this will be set by the application
	if _lccClient == nil {
		return fmt.Errorf("LCC client not initialized")
	}
	
	_lccInitialized = true
	return nil
}

// SetLCCClient sets the LCC client for this package
func SetLCCClient(client *client.Client) {
	_lccClient = client
	_lccInitialized = true
}

{{range .Functions}}
// {{.OriginalName}}_Original is the original implementation
var {{.OriginalName}}_Original = {{.OriginalName}}

// {{.OriginalName}} is the license-protected wrapper
{{.Signature}} {
	// Check license
	if _lccClient != nil {
		status, err := _lccClient.CheckFeature("{{.FeatureID}}")
		if err != nil {
			log.Printf("[LCC] Feature check failed for {{.FeatureID}}: %v", err)
			{{if .HasFallback}}
			// Use fallback
			{{.FallbackCall}}
			{{else}}
			{{.ErrorReturn}}
			{{end}}
		}
		
		if status != nil && !status.Enabled {
			log.Printf("[LCC] Feature {{.FeatureID}} not enabled: %s", status.Reason)
			{{if .HasFallback}}
			// Use fallback
			{{.FallbackCall}}
			{{else}}
			{{.ErrorReturn}}
			{{end}}
		}
		
		// Report usage
		go func() {
			_ = _lccClient.ReportUsage("{{.FeatureID}}", 1.0)
		}()
	}
	
	// Call original function
	{{.OriginalCall}}
}
{{end}}
`

// FunctionTemplate represents a function to be wrapped
type FunctionTemplate struct {
	OriginalName string
	Signature    string
	FeatureID    string
	HasFallback  bool
	FallbackCall string
	ErrorReturn  string
	OriginalCall string
}

// PackageTemplate represents the data for generating a package
type PackageTemplate struct {
	Package   string
	Functions []FunctionTemplate
}

// ZeroIntrusionWrapperTemplate is the template for zero-intrusion wrappers
// This template uses product-level API without featureID parameters
const ZeroIntrusionWrapperTemplate = `// Code generated by lcc-codegen (Zero-Intrusion Mode). DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"log"
	
	"github.com/yourorg/lcc-sdk/pkg/client"
)

var (
	_lccClient *client.Client
	_lccInitialized bool
)

// _lccInit initializes the LCC client (called automatically)
func _lccInit() error {
	if _lccInitialized {
		return nil
	}
	
	// TODO: Load from config file
	// For now, this will be set by the application
	if _lccClient == nil {
		return fmt.Errorf("LCC client not initialized")
	}
	
	_lccInitialized = true
	return nil
}

// SetLCCClient sets the LCC client for this package
func SetLCCClient(client *client.Client) {
	_lccClient = client
	_lccInitialized = true
}

{{range .Functions}}
// {{.OriginalName}}_Original is the original implementation
var {{.OriginalName}}_Original = {{.OriginalName}}

// {{.OriginalName}} is the zero-intrusion license-protected wrapper
{{.Signature}} {
	{{if .HasConcurrency}}
	// Auto-injected: Concurrency control (product-level)
	if _lccClient != nil {
		release, allowed, err := _lccClient.AcquireSlot()
		if err != nil || !allowed {
			log.Printf("[LCC] Concurrency limit exceeded: %v", err)
			{{if .HasFallback}}
			{{.FallbackCall}}
			{{else}}
			{{.ErrorReturn}}
			{{end}}
		}
		defer release()
	}
	{{end}}
	
	{{if .HasQuota}}
	// Auto-injected: Quota consumption (product-level)
	if _lccClient != nil {
		{{if .QuotaConsumer}}
		// Use custom quota consumer
		ctx := context.Background()
		allowed, remaining, err := _lccClient.ConsumeWithContext(ctx{{if .PassArgs}}, args...{{end}})
		{{else}}
		// Use default quota (1 unit per call)
		allowed, remaining, err := _lccClient.Consume(1)
		{{end}}
		if err != nil || !allowed {
			log.Printf("[LCC] Quota exceeded: remaining=%d, err=%v", remaining, err)
			{{if .HasFallback}}
			{{.FallbackCall}}
			{{else}}
			{{.ErrorReturn}}
			{{end}}
		}
	}
	{{end}}
	
	{{if .HasTPS}}
	// Auto-injected: TPS check (product-level)
	if _lccClient != nil {
		allowed, maxTPS, err := _lccClient.CheckTPS()
		if err != nil || !allowed {
			log.Printf("[LCC] TPS exceeded: max=%.2f, err=%v", maxTPS, err)
			{{if .HasFallback}}
			{{.FallbackCall}}
			{{else}}
			{{.ErrorReturn}}
			{{end}}
		}
	}
	{{end}}
	
	{{if .HasCapacity}}
	// Auto-injected: Capacity check (product-level)
	if _lccClient != nil {
		allowed, maxCap, err := _lccClient.CheckCapacityWithHelper()
		if err != nil || !allowed {
			log.Printf("[LCC] Capacity exceeded: max=%d, err=%v", maxCap, err)
			{{if .HasFallback}}
			{{.FallbackCall}}
			{{else}}
			{{.ErrorReturn}}
			{{end}}
		}
	}
	{{end}}
	
	// Call original business logic (zero-intrusion)
	{{.OriginalCall}}
}
{{end}}
`

// ZeroIntrusionFunctionTemplate represents a function for zero-intrusion wrapping
type ZeroIntrusionFunctionTemplate struct {
	OriginalName   string
	Signature      string
	HasConcurrency bool
	HasQuota       bool
	HasTPS         bool
	HasCapacity    bool
	QuotaConsumer  string // Helper function name
	PassArgs       bool   // Whether to pass args to QuotaConsumer
	HasFallback    bool
	FallbackCall   string
	ErrorReturn    string
	OriginalCall   string
}

// ZeroIntrusionPackageTemplate represents the data for generating a zero-intrusion package
type ZeroIntrusionPackageTemplate struct {
	Package   string
	Functions []ZeroIntrusionFunctionTemplate
}
